/*
 * Copyright (c) 2011-2019 Columbia University, System Level Design Group
 * SPDX-License-Identifier: MIT
 */

#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <pthread.h>

#include <stdio.h>
#include <stdint.h>
#include "profpga.h"
#include "mmi64.h"
#include "mmi64_module_regif.h"
#include "mmi64_module_devzero.h"
#include "profpga_error.h"
#include "profpga_acm.h"
#include <stdarg.h>

/* Probes offsets are automatically generated by socmap */
#include "mmi64_regs.h"

static relevant_window = 0;

long long unsigned current_time = 0;
FILE *fp;

void reset_all_counters(mmi64_module_t *user_module)
{
	int i;
	profpga_error_t status;
	int reset_regid = MONITOR_RESET_offset;
	for (i = 0; i < MONITOR_REG_COUNT; i++) {
		int ireg = i;
		status = mmi64_regif_write_32_ack(user_module, reset_regid, 1, &ireg);
	}
}

void read_counter(mmi64_module_t *user_module, int regid)
{
	if (regid >= TOTAL_REG_COUNT) {
		fprintf(stderr, "%s: invalid register id %d; range is [0-%d]\n", __func__, regid, TOTAL_REG_COUNT);
		exit(EXIT_FAILURE);
	}
	profpga_error_t status;
	unsigned rdata;
	status = mmi64_regif_read_32(user_module, regid, 1, &rdata);
	fprintf(fp, "r%d = %d\n", regid, rdata);
}

long long unsigned read_timestamp(mmi64_module_t *user_module)
{
	profpga_error_t status;
	int window_lo_regid = MONITOR_WINDOW_LO_offset;
	int window_hi_regid = MONITOR_WINDOW_HI_offset;
	long long unsigned time_stamp = 0;
	unsigned rdata;
	status = mmi64_regif_read_32(user_module, window_hi_regid, 1, &rdata);
	time_stamp = ((long long unsigned) rdata) << 32;
	status = mmi64_regif_read_32(user_module, window_lo_regid, 1, &rdata);
	time_stamp |= (long long unsigned) rdata;
	return time_stamp;
}

#ifdef DDR_offset
void read_ddr(mmi64_module_t *user_module)
{
	profpga_error_t status;
	int i;
	for (i = 0; i < DDRS_NUM; i++) {
		int ddr_regid = DDR_offset + i;
		unsigned ddr;
		status = mmi64_regif_read_32(user_module, ddr_regid, 1, &ddr);
		fprintf(fp, "%d\t", ddr);
	}
}
#endif

#ifdef NOC_INJECT_offset
void read_injection_rate(mmi64_module_t *user_module)
{
	profpga_error_t status;
	int i, k;
	unsigned rdata[NOCS_NUM][TILES_NUM];
	for (k = 0; k < NOCS_NUM; k++) {
		for (i = 0; i < TILES_NUM; i++) {
			int injection_regid = NOC_INJECT_offset + (k * TILES_NUM) + i;
			status = mmi64_regif_read_32(user_module, injection_regid, 1, &rdata[k][i]);
		}
	}
	for (k = 0; k < NOCS_NUM; k++)
		for (i = 0; i < TILES_NUM; i++)
			fprintf(fp, "%d\t", rdata[k][i]);

}
#endif

#ifdef NOC_QUEUES_offset
void read_queues(mmi64_module_t *user_module)
{
	/*
	 * N = 0
	 * S = 1
	 * W = 2
	 * E = 3
	 * L = 4
	 */
	profpga_error_t status;
	int i, j, k;
	unsigned rdata[NOCS_NUM][TILES_NUM][DIRECTIONS];
	for (k = 0; k < NOCS_NUM; k++) {
		for (i = 0; i < TILES_NUM; i++)
			for (j = 0; j < DIRECTIONS; j++) {
				int regid = NOC_QUEUES_offset + (k * TILES_NUM * DIRECTIONS) + (i * DIRECTIONS) + j;
				status = mmi64_regif_read_32(user_module, regid, 1, &rdata[k][i][j]);
			}
	}
	for (k = 0; k < NOCS_NUM; k++)
		for (i = 0; i < TILES_NUM; i++)
			for (j = 0; j < DIRECTIONS; j++)
				fprintf(fp, "%d\t", rdata[k][i][j]);

}
#endif

#ifdef ACC_offset
void read_accelerator(mmi64_module_t *user_module, int accelerator)
{
	/*
	 * TLB = 0
	 * MEM_LO = 1
	 * MEM_HI = 2
	 * TOT_LO = 3
	 * TOT_HI = 4
	 */
	profpga_error_t status;
	int tlb_regid    = ACC_offset + accelerator * 5 + 0;
	int mem_lo_regid = ACC_offset + accelerator * 5 + 1;
	int mem_hi_regid = ACC_offset + accelerator * 5 + 2;
	int tot_lo_regid = ACC_offset + accelerator * 5 + 3;
	int tot_hi_regid = ACC_offset + accelerator * 5 + 4;

	long long unsigned tlb = 0;
	long long unsigned mem = 0;
	long long unsigned tot = 0;
	unsigned rdata;
	status = mmi64_regif_read_32(user_module, tot_hi_regid, 1, &rdata);
	tot = ((long long unsigned) rdata) << 32;
	status = mmi64_regif_read_32(user_module, tot_lo_regid, 1, &rdata);
	tot |= (long long unsigned ) rdata;
	status = mmi64_regif_read_32(user_module, mem_hi_regid, 1, &rdata);
	mem = ((long long unsigned) rdata) << 32;
	status = mmi64_regif_read_32(user_module, mem_lo_regid, 1, &rdata);
	mem |= (long long unsigned ) rdata;
	status = mmi64_regif_read_32(user_module, tlb_regid, 1, &rdata);
	tlb = (long long unsigned) rdata;

	fprintf(fp, "%d\t%d\t%d\t", tlb, mem, tot);
}

void read_accelerators(mmi64_module_t *user_module)
{
	int i;
	for (i = 0; i < ACCS_NUM; i++)
		read_accelerator(user_module, i);
}
#endif

#ifdef DVFS_offset
void read_dvfs(mmi64_module_t *user_module)
{
	profpga_error_t status;
	int i, k;
	unsigned rdata[TILES_NUM][VF_OP_POINTS];
	for (k = 0; k < TILES_NUM; k++) {
		for (i = 0; i < VF_OP_POINTS; i++) {
			int dvfs_regid = DVFS_offset + (k * VF_OP_POINTS) + i;
			status = mmi64_regif_read_32(user_module, dvfs_regid, 1, &rdata[k][i]);
		}
	}
	for (k = 0; k < TILES_NUM; k++) {
		for (i = 0; i < VF_OP_POINTS; i++) {
			if (rdata[k][i] != 0 && tiles[k].domain != 0)
				relevant_window = 1;
			fprintf(fp, "%d\t", rdata[k][i]);
		}
	}

}
#endif


void set_window(mmi64_module_t *user_module, int window)
{
	profpga_error_t status;
	int window_size_regid = MONITOR_WINDOW_SIZE_offset;
	status = mmi64_regif_write_32_ack(user_module, window_size_regid, 1, &window);
}

#define CHECK(status)  if (status!=E_PROFPGA_OK) { \
  printf(NOW("ERROR: %s\n"), profpga_strerror(status)); \
  return status;  }


int message_handler(const int messagetype, const char *fmt,...)
{
  int n;
  va_list ap;
  va_start(ap, fmt);
  n = vfprintf(stdout, fmt, ap);
  va_end(ap);
  return n;
}

char * cfgfilename = "profpga.cfg";


void *wait_for_user_stop(void *stop)
{
	char val;
	int *local_stop = (int *) stop;
	printf("Press any key to stop Monitor...\n");
	scanf("%c", &val);
	*local_stop = 1;
	return NULL;
}

mmi64_error_t mmi64_main(int argc, char * argv[])
{
  profpga_handle_t * profpga;
  profpga_error_t status;
  uint32_t data[8];
  const mmi64_addr_t user_addr[] = {2, 1, 0};
  mmi64_module_t * user_module;

  int mh_status = profpga_set_message_handler(message_handler);
  int i, k ;

  pid_t pid;
  pthread_t aux;
  int stop = 0;
  long long unsigned new_time;

  if (mh_status!=0) {
    printf("ERROR: Failed to install message handler (code %d)\n", mh_status);
    return mh_status;
  }

  // connect to system
  printf(NOW("Open connection to profpga platform...\n"));

  status = profpga_open (&profpga, cfgfilename);
  if (status!=E_PROFPGA_OK) { // cannot use NOW() macro because required MMI-64 domain handle has not been initialized
    printf("ERROR: Failed connect to PROFPGA system (%s)\n", profpga_strerror(status));
    return status;
  }

#ifdef HDL_SIM
  // for HDL simulation: perform configuration as done by profpga_run --up
  printf(NOW("Bring up system.\n"));
  status = profpga_up(profpga);
  CHECK(status);
#endif

  // scan for MMI-64 modules
  printf(NOW("Scan hardware...\n"));
  status = mmi64_identify_scan(profpga->mmi64_domain);
  CHECK(status);

  // print scan results
  status = mmi64_info_print(profpga->mmi64_domain);
  CHECK(status);

  // find user module
  status = mmi64_identify_by_address(profpga->mmi64_domain, user_addr, &user_module);
  CHECK(status);
  if (user_module==NULL) {
    printf("ERROR: Failed to identify user module. \n");
    return -1;
  }


  /* Open report file */
  fp = fopen("mmi64.rpt", "w+");

  /* Create a thread to stop probing */
  if (pthread_create(&aux, NULL, wait_for_user_stop, (void *) &stop)) {
	  fprintf(stderr, "Error creating thread\n");
	  exit(EXIT_FAILURE);
  }

  /* Print report header */
  fprintf(fp, "window\t");

#ifdef DDR_offset
  fprintf(fp, "ddr0\tddr1\t");
#endif

#ifdef NOC_INJECT_offset
  for (k = 0; k < NOCS_NUM; k++)
	  for (i = 0; i < TILES_NUM; i++)
		  fprintf(fp, "inj-%d-%d\t", k, i);
#endif

#ifdef NOC_QUEUES_offset
  for (k = 0; k < NOCS_NUM; k++)
	  for (i = 0; i < TILES_NUM; i++) {
		  fprintf(fp, "t-%d-%d-n\t", k, i);
		  fprintf(fp, "t-%d-%d-s\t", k, i);
		  fprintf(fp, "t-%d-%d-w\t", k, i);
		  fprintf(fp, "t-%d-%d-e\t", k, i);
		  fprintf(fp, "t-%d-%d-l\t", k, i);
	  }
#endif

#ifdef ACC_offset
  for (k = 0; k < ACCS_NUM; k++) {
	  fprintf(fp, "tlb-%d\t", k);
	  fprintf(fp, "mem-%d\t", k);
	  fprintf(fp, "tot-%d\t", k);
  }
#endif

#ifdef DVFS_offset
  for (k = 0; k < TILES_NUM; k++)
	  for (i = 0; i < VF_OP_POINTS; i++)
		  fprintf(fp, "vf-%d-%d\t", k, i);
#endif

  fprintf(fp, "\n");
  fflush(fp);

  /* Set probing time frame or window */
  set_window(user_module, (1<<20));

  /* Read probes once per window; mmi returns values sampled at the end of each window */
  while(!stop) {
  	  new_time = read_timestamp(user_module);
  	  if (new_time != current_time) {
		  relevant_window = 0;
  		  current_time = new_time;
  		  fprintf(fp, "%d\t", new_time);
#ifdef DDR_offset
 		  read_ddr(user_module);
#endif
#ifdef NOC_INJECT_offset
		  read_injection_rate(user_module);
#endif
#ifdef NOC_QUEUES_offset
 		  read_queues(user_module);
#endif
#ifdef ACC_offset
		  read_accelerators(user_module);
#endif
#ifdef DVFS_offset
		  read_dvfs(user_module);
#endif
		  if (!relevant_window)
			  fprintf(fp, "N");
  		  fprintf(fp, "\n");
		  fflush(fp);
  	  }
  }

  /* Close system */
  printf(NOW("Done. Closing connection...\n"));
  return profpga_close(&profpga);
}

#ifndef HDL_SIM
int main(int argc, char * argv[])
{
  if (argc!=2) {
    printf("Wrong arguments! Usage:\n    mmi64basic_test [CONFIGFILE.cfg]\n");
    return -1;
  }
  printf("Using configuration file %s\n", argv[1]);
  cfgfilename = argv[1];
  return  mmi64_main(argc, argv);
}
#endif
