// Copyright (c) 2011-2021 Columbia University, System Level Design Group
// SPDX-License-Identifier: Apache-2.0
#include <stdint.h>
#include <stdio.h>

#ifndef RISCV_CSR_ENCODING_H
#define RISCV_CSR_ENCODING_H

#define MSTATUS_MIE         0x00000008
#define MIP_MTIP            (1 << IRQ_M_TIMER)
#define IRQ_M_TIMER  7

#ifdef __riscv

#ifndef __ASSEMBLER__

#ifdef __GNUC__

#define read_csr(reg) ({ unsigned long __tmp; \
  asm volatile ("csrr %0, " #reg : "=r"(__tmp)); \
  __tmp; })

#define write_csr(reg, val) ({ \
  asm volatile ("csrw " #reg ", %0" :: "rK"(val)); })

#define swap_csr(reg, val) ({ unsigned long __tmp; \
  asm volatile ("csrrw %0, " #reg ", %1" : "=r"(__tmp) : "rK"(val)); \
  __tmp; })

#define set_csr(reg, bit) ({ unsigned long __tmp; \
  asm volatile ("csrrs %0, " #reg ", %1" : "=r"(__tmp) : "rK"(bit)); \
  __tmp; })

#define clear_csr(reg, bit) ({ unsigned long __tmp; \
  asm volatile ("csrrc %0, " #reg ", %1" : "=r"(__tmp) : "rK"(bit)); \
  __tmp; })

#endif

#endif

#endif

#endif
/* Automatically generated by parse-opcodes.  */
#ifndef RISCV_ENCODING_H
#define RISCV_ENCODING_H
#define CSR_MHARTID 0xf14
#endif

#ifdef DECLARE_CSR
DECLARE_CSR(mhartid, CSR_MHARTID)
#endif

#define MTIME           (*(volatile long long *)(0x02000000 + 0xbff8))
#define MTIMECMP        ((volatile long long *)(0x02000000 + 0x4000))

#define csr_read(csr)                                   \
({                                                      \
    register unsigned long __v;                         \
    __asm__ __volatile__ ("csrr %0, " #csr              \
                  : "=r" (__v));                        \
    __v;                                                \
})

typedef void* (*trap_handler_t)(unsigned hartid, unsigned mcause, void *mepc,
        void *sp);
void set_trap_handler(trap_handler_t handler);
void enable_timer_interrupts();

#define NHARTS 4
trap_handler_t trap_handler[NHARTS] = {0};

void set_trap_handler(trap_handler_t handler)
{
    unsigned hartid = csr_read(mhartid);
    trap_handler[hartid] = handler;
}

void enable_timer_interrupts()
{
    set_csr(mie, MIP_MTIP);
    set_csr(mstatus, MSTATUS_MIE);
}

void handle_trap(unsigned int mcause, void *mepc, void *sp)
{
    unsigned hartid = csr_read(mhartid);
    if (trap_handler[hartid]) {
        trap_handler[hartid](hartid, mcause, mepc, sp);
        return;
    }

    while (1)
        ;
}

void _exit(int status)
{
    // Make sure gcc doesn't inline _exit, so we can actually set a breakpoint
    // on it.
    volatile int i = 42;
    while (i)
        ;
    // _exit isn't supposed to return.
    while (1)
        ;
}


typedef struct {
    int counter;
} atomic_t;

static inline int atomic_xchg(atomic_t *v, int n)
{
    register int c;

    __asm__ __volatile__ (
            "amoswap.w.aqrl %0, %2, %1"
            : "=r" (c), "+A" (v->counter)
            : "r" (n));
    return c;
}

static inline void mb(void)
{
    __asm__ __volatile__ ("fence");
}

void get_lock(atomic_t *lock)
{
    while (atomic_xchg(lock, 1) == 1)
        ;
    mb();
}

void put_lock(atomic_t *lock)
{
    mb();
    atomic_xchg(lock, 0);
}

static atomic_t buf_lock = { .counter = 0 };
static char buf[32];
static int buf_initialized;
static unsigned hart_count[NHARTS];
int shared_count;
static unsigned interrupt_count[NHARTS];

static unsigned delta = 0x100;
void *increment_count(unsigned hartid, unsigned mcause, void *mepc, void *sp)
{
    interrupt_count[hartid]++;
    MTIMECMP[hartid] = MTIME + delta;
    return mepc;
}

void thread_entry(int cid, int nc)
{
      // multi-threaded programs override this function.
      //   // for the case of single-threaded programs, only let core 0 proceed.
      return;
}

int main()
{
    uint32_t hartid = csr_read(mhartid);
    hart_count[hartid] = 0;
    interrupt_count[hartid] = 0;
    buf_initialized = 0;
    set_trap_handler(increment_count);
    // Despite being memory-mapped, there appears to be one mtimecmp
    // register per hart. The spec does not address this.
    MTIMECMP[hartid] = MTIME + delta;
    enable_timer_interrupts();
    shared_count = 0;
    while (1) {
        get_lock(&buf_lock);

        shared_count++;
        hart_count[hartid]++;
        int total = 0;
        for (int i = 0; i < NHARTS; i++) {
            total += hart_count[i];
        }
        if (total != shared_count){
            printf("ERR ERR ERR total: %d, shared: %d!\n", total, shared_count);
            break;
        }
        if (shared_count % 5 == 0)
            printf("count is %d: %d %d %d %d\n", shared_count, hart_count[0], hart_count[1], hart_count[2], hart_count[3]);
        put_lock(&buf_lock);
    }
}
